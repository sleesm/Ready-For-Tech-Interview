## 운영체제의 개요

[운영체제와 정보 기술의 원리](http://www.yes24.com/Product/Goods/2824944)라는 책을 읽고 정리한 내용입니다.

1장을 정리했습니다. 내용은 전반적으로 얕게 설명되어 있는 장입니다. 



### 운영체제란?

운영체제(Operating System 이하 OS)란 컴퓨터 하드웨어 바로 윗단에 설치되는 소프트웨어를 말한다. 컴퓨터를 구성하는 요소 중 운영체제의 위상은 아래와 같다.

![img](https://k.kakaocdn.net/dn/bjhadS/btqvnG48wLg/CBJNdOaJaDAZlt0rK5jMR1/img.png)

OS 자체도 하나의 소프트웨어로서 전원이 켜짐과 동시에 메모리에 올라간다. 하지만, OS처럼 규모가 큰 프로그램이 모두 메모리에 올라간다면 한정된 메모리 공간의 낭비가 발생한다. 따라서  운영 체제 중 항상 필요한 부분만을 전원이 켜짐과 동시에 메모리에 올려놓고 그렇지 않은 부분은 필요할 때, 메모리로 올려서 사용하게 된다.

- 메모리에 상주하는 운영체제의 부분 -> 커널(Kernel) [좁은 의미의 운영체제]
- 커널은 운영체제 코드 중에서 핵심적인 부분.



### 운영체제의 기능

운영체제는 컴퓨터 하드웨어와 사용자 사이에 존재하며, 사용자가 직접 운영하기 힘든 하드웨어에 대해서 운영체제가 관리하기도 하고 사용자에게는 편리한 인터페이스를 제공하는 역할도 한다. 우리가 흔히 아는 Windows Sereis, Mac OS 같은 것들이 예시가 된다.



간단하게 정리하면 아래와 같다.

- 컴퓨터 시스템 내의 자원을 효율적으로 관리하는 것
- 컴퓨터 시스템을 편리하게 사용할 수 있는 환경을 제공하는 것
- 사용자 및 프로그램들 간에 자원이 형평성 있게 분배되도록 하는 균형자 역할도 제공한다.
- 사용자와 운영 체제 자신을 보호하는 역할을 담당.



### 운영체제의 분류

동시 작업을 지원하는지 여부에 따라 단일 작업용 운영체제와 다중 작업용 운영체제로 나누어 볼 수 있다.

1) 단일 작업용 운영체제

- 한 번에 하나의 프로그램만 수행시킬 수 있는 운영체제
- MS 윈도즈가 나오기 전 DOS 환경에서는 하나의 프로그램이 수행되는 동안 다른 프로그램을 수행시킬 수 있는 명령어 입력 라인이 뜨지 않아 한번에 하나의 작업만 할 수 있었다.



최근에는 대부분의 운영체제가 다중 작업을 지원한다.

MS 윈도즈나 유닉스 환경에서는 하나의 프로그램의 수행이 끝나기 전에 다른 프로그램을 수행시키는 것이 가능하다.

주의할 점으로는 다중 작업용 운영체제에서는 여러 프로그램이 CPU와 메모리를 공유하게 된다. 하지만 일반적으로 CPU는 하나밖에 없으며, 다중 작업용 운영체제라도 CPU에서는 매순간 하나의 프로그램만이 수행되는 것이다.

이는 CPU의 처리 속도가 워낙 빨라 수 ms 이내의 짧은 시간 규모로 여러 프로그램이 CPU에서 번걸아 수행되기 때문에 여러 프로그램이 동시에 수행되는 것처럼 보인다.



**[다중 작업용 운영체제의 분류]**

- 시분할 시스템 : CPU의 작업 시간을 여러 프로그램들이 조금씩 나누어 쓰는 시스템
- 다중 프로그래밍 시스템 : 메모리 공간을 분할해 여러 프로그램들을 동시에 메모리에 올려놓고 처리하는 시스템
- 다중처리기 시스템 : 하나의 컴퓨터 안에 CPU가 여러 개 설치된 시스템.



**[다중 사용자의 동시 지원 여부]**

- 단일 사용자용 운영체제 : 한 번에 한명의 사용자만이 사용하도록 허용하는 운영체제
- 다중 사용자용 운영체제 : 여러 사용자가 동시에 접속해 사용할 수 있게 하는 운영체제
  - Ex) 이메일 서버,웹 서버, MS 윈도즈 등등



**[작업을 처리하는 방식에 따른 분류]**

- **일괄 처리** : 작업 요청의 일정량을 모아서 한꺼번에 처리하는 방식. 따라서 모든 작업이 완전히 종료된 후에 결과를 얻을 수 있다.
  - 응답 시간이 길다는 단점이 존재.
- **시분할 방식** : 여러 작업을 수행할 때 컴퓨터의 처리 능력을 일정한 시간 단위로 분할해 사용하는 방식
  - 일괄 처리 방식에 비해 짧은 응답 시간을 갖는다. 
  - 평균적으로 사람이 길다고 느끼는 시간 전에 요청에 대한 응답을 얻으므로 사용자 측에서는 컴퓨터를 혼자 독점적으로 사용하는 것처럼 생각할 수 있다.
  - 이와 같이 사용자의 요청에 대한 결과를 곧바로 얻을 수 있는 시스템을 대화형 시스템이라 부르며, 시분할 방식이 대표적인 예이다.
- 실시간 처리 : 정해진 시간 안에 어떠한 일이 반드시 종료됨이 보장되어야 하는 시스템
  - 시간 제약의 중요성에 따라 아래와 같이 두 가지로 나뉜다.
    1. 경성 실시간 시스템 : 주어진 시간을 지키지 못할 경우, 매우 위험한 결과를 초래할 가능성이 있는 로켓, 원자로 제어 시스템 등을 말한다.
    2. 연성 실시간 시스템 : 멀티미디어 스트리밍 시스템과 같이 데이터가 시간을 맞추어 전달되어야 올바른 기능을 수행할 수 있는 시스템. (위험한 결과를 초래하지는 않는다.)



### 운영체제의 자원 관리 기능

운영 체제의 가장 핵심적인 기능은 자원을 효율적으로 관리하는 것이다. 

**[자원]**

- 하드 웨어 자원 : CPU, 메모리 및 주변 장치, 입출력 장치 등.
- 소프트웨어 자원



**[운영체제의 기능 요약]**

- CPU 스케줄링 : 어떤 프로그램에게 CPU를 줄 것인가?
- 메모리 관리 : 한정된 메모리를 어떻게 나누어 사용할 것인가?
- 파일 관리 : 디스크에 파일을 어떻게 보관할 것인가?
- 입출력 관리 : 각기 다른 입출력 장치와 컴퓨터 간에 어떻게 정보를 주고 받을 것인가?
- 프로세스 관리
  - 프로세스의 생성과 삭제
  - 자원 할당 및 반환
  - 프로세스 간 협력
- 그 외
  - 보호 시스템
  - 네트워킹
  - 명령어 해석기



**[CPU 관리]**

- CPU가 하나밖에 없지만 프로세스는 여러개가 동시에 실행된다. 그러므로 매 시점 어떠한 프로세스에게 CPU를 할당해 작업을 처리할 것인지 결정해야 한다. 이러한 일을 **CPU 스케줄링**이라 한다. 
- 목표 : CPU를 가장 효율적으로 사용하면서도 특정 프로세스가 불이익을 당하지 않도록 하는 것이다.



1) 선입 선출(FCFS : First Come First Served)

- CPU를 사용하기 위해 먼저 도착한 프로세스를 먼저 처리하는 방식
- 일상 생활에서 줄서기와 유사하다.
- CPU를 필요로 하는 프로세스가 여럿 있을 때 먼저 CPU를 요청한 프로세스가 원하는 작업을 완료할 때까지 다른 프로세스들이 CPU를 사용하지 못하게 된다. 따라서 장시간 CPU를 사용해야 하는 프로세스가 먼저 도착해 CPU를 사용하면 이후에 도착한 짧은 시간 CPU를 사용해야 하는 프로세스는 앞서 도착한 프로세스의 작업이 끝날 때까지 하염없이 기다리게 되어 비효율적인 결과를 초래할 가능성이 있다. (단점)



2) 라운드 로빈 기법

- FCFS의 단점을 보완하고자 등장.
- CPU를 한 번 할당받아 사용할 수 있는 시간을 일정한 고정된 시간으로 제한한다.
- 그래서 긴 작업을 요하는 프로세스가 CPU를 할당받더라도 정해진 시간이 지나면 CPU를 내어놓고 CPU의 서비스를 기다리는 줄의 제일 뒤에 가서 기다려야 한다.
- 따라서 적어도 긴 작업을 수행하는 프로세스 때문에 짧은 작업을 가진 프로세스들이 무작정 오래 기다려야 하는 상황을 막을 수 있다.
- 일반적으로 1회 할당 시간은 수 밀리 세컨드(ms) 정도의 단위를 사용한다.



3) 우선 순위 스케줄링

- 수행 대기 중인 프로세스들에게 우선 순위를 부여하고 우선순위가 높은 프로세스에게 CPU를 먼저 할당하게 된다.
- 또한, 지나치게 오래 기다리는 프로세스가 발생하지 않도록 기다린 시간이 늘어날수록 우선순위를 점차 높여주는 방안도 우선순위 스케줄링에 활용될 수 있다.



**[메모리 관리]**

메모리는 CPU가 직접 접근할 수 있는 컴퓨터 내부의 기억 장치이다.

프로그램이 CPU에서 수행되려면 해당 부분이 메모리에 올라가 있어야 한다. 한정된 메모리 공간에 여러 프로그램을 수용하려면 메모리에 대한 효율적인 메커니즘이 필요하다.

- 운영 체제는 각 프로세스가 자신의 메모리 영역만을 접근할 수 있도록 관리해야 한다.



1) 물리적 메모리

- 고정 분할 방식
  - 물리적 메모리를 몇 개의 영구적인 분할로 나눈다.
  - 각각의 분할에는 하나의 프로그램이 적재된다.
  - 분할의 크기보다 큰 프로그램은 적재가 불가능하며, 동시에 메모리에 적재되는 프로그램의 수는 분할 개수로 한정된다.
  - 분할의 크기가 고정적이기 때문에 분할의 크기보다 작은 프로그램이 적재되는 경우 남는 영역이 발생하며 이를 **내부 조각**이라고 한다.
  - `내부 조각` : 분할 영역에 올라온 프로그램에 의해서도 사용되지 않고, 다른 프로세스에게도 할당될 수 없으므로 비효율적으로 낭비되는 공간.

- 가변 분할 방식
  - 매 시점 프로그램의 크기에 맞게 메모리를 분할해서 사용하는 방식.
  - 물리적 메모리 크기보다 더 큰 프로그램의 실행은 여전히 불가능하다.
  - 분할의 크기, 개수가 동적으로 변하므로 기술적 관리 기법이 필요하다.
  - **외부 조각**이 발생할 수 있다.
  - `외부 조각` : 프로그램에게 할당되지 않은 메모리 영역이지만 그 크기가 작아 프로그램을 올리지 못하는 메모리 영역.

- 가상 메모리 방식
  - 물리적 메모리보다 더 큰 프로그램이 실행되는 것을 지원한다.
  - 자신만의 가상 메모리를 갖고 물리적 메모리 주소와 가상 메모리의 주소를 매핑하는 기술을 이용해 주소를 변환시킨 후 프로그램을 물리적 메모리에 올린다.
  - 필요한 부분만을 메모리에 올리고 나머지는 스왑 영역(swap area)에 저장하여 사용한다.(스왑 영역 : 보조기억 장치)
  - 프로그램을 구성하는 주소 공간은 페이지라는 동일한 크기의 작은 단위로 나뉘어 물리적 메모리와 스왑 영역에 일부분씩 저장한다.
  - 동일한 단위로 메모리를 나누는 기법 -> 페이징





주변 장치 및 입출력 장치

- CPU나 메모리와 달리 인터럽트라는 매커니즘을 통해 관리한다.
- 인터럽트 : CPU의 서비스가 필요한 경우에 신호를 발생시켜 서비스를 요청하게 되는데, 이때 발생시키는 신호를 의미한다.
- 인터럽트 발생시 직전 작업 상태를 저장해두고 인터럽트를 처리한다. 인터럽트 처리가 완료된 이후에는 인터럽트가 발생하기 직전 상태를 복구시켜 중단되었던 작업을 재개한다. (저장해둔 직접 작업을 불러와 이어서 수행한다.)
- 인터럽트 처리 루틴 : 인터럽트가 발생했을 때, 해주어야 할 작업을 정의한 프로그램 코드.
- 컨트롤러를 통해 주변 및 외부 장치를 관리한다.
- 컨트롤러는 해당 장치에 대한 업무를 처리하고 이를 메인 CPU에 인터럽트를 발생시켜 보고하는 역할을 한다.
- Ex) 키보드에 사용자가 입력을 하면 키보드 컨트롤러가 인터럽트를 발생시켜 CPU에게 그 사실을 알려준다. CPU는 현재 수행중이던 작업의 상태를 저장하고 인터럽트 요청을 처리하기 위해 운영 체제 내에 정의된 키보드 인터럽트 처리 루틴을 찾는다. 키보드 인터럽트 처리루틴을 실행하고 완료하게 된다. 인터럽트 처리가 끝나면 인터럽트가 발생하기 직전 상태를 복구시켜 중단되었던 작업을 재개한다.